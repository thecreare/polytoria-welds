import os
import yaml
import json

TYPE_MAP = {
	"function": "() -> ()",
	"table": "{}",
}

BARE_HEADER = """export type Event<Callback = (...unknown) -> (), Parameters... = ...unknown> = {
	Connect: (self: Event<Callback, Parameters...>, callback: Callback) -> (),
	Disconnect: (self: Event<Callback, Parameters...>, callback: Callback) -> ()
}

declare class Enum
    function GetEnumItems(self): { any }
    function FromValue(self,Number: number): any
    function FromName(self,Name: string): any
end

declare class EnumItem
    Name: string
    Value: number
    EnumType: Enum
    function IsA(self, enumName: string): boolean
end

"""

def map_type(ty):
	if ty in TYPE_MAP: return TYPE_MAP[ty]
	return ty

# os.system("rm -rf tmp")
if not os.path.isdir('tmp'):
	os.system("git clone --depth 1 https://github.com/Polytoria/Docs-v2.git tmp")

def parse_yaml_directory(dir):
	loaded = []
	for e in os.scandir(dir):
		if not e.is_file(): continue
		with open(e.path, "r") as f:
			loaded.append(yaml.safe_load(f))
	return loaded

classes = parse_yaml_directory("tmp/yaml/types")
enums = parse_yaml_directory("tmp/yaml/enums")

doc_out = {}

with open("polytoria_autogenerated.d.luau", "w") as output:
	output.write(BARE_HEADER)

	_current_indent = 0
	def write_line(line):
		global _current_indent
		if line.endswith("end"): _current_indent -= 1
		if line.startswith("}"): _current_indent -= 1
		indent = "\t" * _current_indent
		output.write(f"{indent}{line}\n")
		if line.startswith("declare class"): _current_indent += 1
		if line.endswith("{"): _current_indent += 1

	enum_type_list = []
	for enum in enums:
		write_line(f"declare class {enum["Name"]} extends EnumItem end")
		write_line(f"declare class {enum["InternalName"]} extends Enum")

		for option in enum["Options"]:
			write_line(f"{option["Name"]}: {enum["InternalName"]}")

		write_line(f"function GetEnumItems(self): {{ {enum["Name"]} }}")
		write_line(f"function FromName(self, Name: string): {enum["Name"]}?")
		write_line(f"function FromValue(self, Value: number): {enum["Name"]}??")
		write_line("end")
		write_line("")

		enum_type_list.append(f"{enum["Name"]}: {enum["InternalName"]},")
	
	write_line("type ENUM_LIST = {")
	for item in enum_type_list:
		write_line(item)
	write_line("} & { GetEnums: (self: ENUM_LIST) -> { Enum } }")
	write_line("declare Enum: ENUM_LIST")
	write_line("")

# Methods:
#   - Name: BroadcastMessage
#     ReturnType: nil
#     Parameters:
#       - Name: msg
#         Type: string
#         IsOptional: false
#         DefaultValue: ""
#     IsAsync: false
#     IsObsolete: false
#     IsStatic: false
#     Description: Sends a chat message to all players.
#   - Name: UnicastMessage
#     ReturnType: nil
#     Parameters:
#       - Name: msg
#         Type: string
#         IsOptional: false
#         DefaultValue: ""
#       - Name: plr
#         Type: Player
#         IsOptional: false
#         DefaultValue: ""
#     IsAsync: false
#     IsObsolete: false
#     IsStatic: false
#     Description: Sends a chat message to a specific player.

	def write_def(raw):
		base_type = raw["BaseType"]
		write_line(f"declare class {raw["Name"]}" + (" extends " + base_type if base_type else ""))

		doc_out[f"@standard/globaltype/{raw["Name"]}"] = {
			"documentation": c["Description"],
		}
		doc_out[f"@standard/global/{raw["Name"]}"] = {
			"documentation": c["Description"],
		}

		readonly_properties = []
		for prop in raw["Properties"]:
			line = f"{prop["Name"]}: {map_type(prop["Type"])}"
			if prop["IsReadOnly"]:
				prop["_line"] = line + ","
				readonly_properties.append(prop)
				continue
			write_line(line)

		for event in raw["Events"]:
			args = []
			for arg in ( [] if event["Arguments"] == "" else event["Arguments"] if type(event["Arguments"]) == list else [event["Arguments"]] ):
				if arg["Name"] == "...":
					args.append(f"...{map_type(arg["Type"])}")
				else:
					args.append(f"{arg["Name"]}: {map_type(arg["Type"])}")
			write_line(f'{event["Name"]}: Event<({", ".join(args)}) -> ()>')

		static_methods = {}
		dynamic_methods = {}
		for method in raw["Methods"]:
			return_value = map_type(method["ReturnType"])
			method_name = method["Name"]
			if return_value == "nil": return_value = "()"
			params = ", ".join([f"{param["Name"]}: {map_type(param["Type"])}{"?" if param["IsOptional"] else ""}" for param in method["Parameters"]])

			method["_params"] = params
			method["_return"] = return_value

			methods_list = static_methods if method["IsStatic"] else dynamic_methods

			if method_name in methods_list: methods_list[method_name].append(method)
			else: methods_list[method_name] = [method]


		for methods in dynamic_methods.values():
			if len(methods) > 1:
				print(f"Can't do methods {methods}")
				continue
			for method in methods:
				params = method["_params"]
				comma = ", " if len(params) > 0 else ""
				write_line(f"function {method["Name"]}(self{comma}{params}): {method["_return"]}")

		write_line("end")
		write_line("")

		# TODO: Static support (ex, an Instance class with just .New() and its correct type def)
		# IsStatic: false # ChatService
		# IsAbstract: false # Instance
		# IsInstantiatable: true # Part

		if len(static_methods) > 0 or len(readonly_properties) > 0:
			write_line(f"declare {raw["Name"]}" + ": {")
			for prop in readonly_properties:
				write_line(prop["_line"])
			for method_name, methods in static_methods.items():
				funcs = " & ".join([f"(({method["_params"]}) -> ({method["_return"]}))" for method in methods])
				write_line(f"{method_name}: {funcs},")
			write_line("}")
			write_line("")


	queue = []
	for c in classes:
		if c["BaseType"] == None:
			write_def(c)
			queue.append(c)

	while len(queue) > 0:
		working = queue.pop()
		for other in classes:
			if other["BaseType"] == working["Name"]:
				write_def(other)
				queue.append(other)

with open('polytoria_documentation.d.json', 'w') as f:
    json.dump(doc_out, f, indent=2)
